
//Common parameters for the model Hamiltonian
model::model_type                         = ising_majorana                    /*!< Choice of model: {ising_tf_rf,ising_sdual, ising_majorana, lbit} */
model::model_size                         = 16                                /*!< Number of sites on the chain. Only relevant for finite algorithms: fDMRG and xDMRG */

//Console settings
console::loglevel                         = 2                                 /*!< Verbosity [0-6]. Level 0 prints everything, 6 nothing. Level 2 or 3 is recommended for normal use */
console::logh5pp                          = 2                                 /*!< Verbosity of h5pp library [0-6] Level 2 or 3 is recommended for normal use */
console::timestamp                        = true                              /*!< (NOT IMPLEMENTED) Whether to put a timestamp on console outputs */

// Parameters for Multithreading
threading::stl_threads                    = 1                                 /*!< Number of threads for openmp threads used in blas/lapack and Eigen. num_threads <= 0 will try to use as many as possible */
threading::omp_threads                    = 1                                 /*!< Number of threads for c++11 threading. Used in Eigen::Tensor. stl_threads <= 0 will try to use as many as possible */

//Parameters to control timers.
timer::on                                 = true                              /*!< If true, turns on timers. These will be shown on console. */
timer::precision                          = 5                                 /*!< Sets precision (number of decimals) of time output. */
timer::level                              = normal                            /*!< How much detail to print on exit [normal | extra | detailed]  */

// Input parameters (note that CLI parameters overrwide these)
input::seed                               = 1                                 /*!< Main seed for the random number generator. */
input::bitfield                           = -1                                /*!< Number whose bitfield represents the initial product state in the basis given by initial_parity_sector. Only positive state numbers are used */

//Parameters for saving data to hdf5
storage::output_filepath                  = ../output/mbl.h5                  /*!< Name of the output HDF5 file relative to the execution point  */
storage::save_timers                      = true                              /*!< Save timer information to file (on storage level FULL|NORMAL) */
storage::savepoint_keep_newest_only       = true                              /*!< If true, a savepoint will overwrite previous savepoints on file. Otherwise, all iterations are kept (dramaticallay increases file size) */
storage::savepoint_frequency              = 0                                 /*!< How often, in units of iterations, to make a savepoint. 0 disables savepoints after iterations (bond-update savepoints can still happen) */
storage::checkpoint_keep_newest_only      = true                              /*!< If true, a checkpoint will overwrite previous checkpoint on file. Otherwise, all iterations are kept (dramaticallay increases file size) */
storage::checkpoint_frequency             = 1                                 /*!< How often, in units of iterations, to make a checkpoint. 0 disables checkpoints but bond-update checkpoints can still happen */
storage::use_temp_dir                     = true                              /*!< If true uses a temporary directory for writes in the local drive (usually /tmp) and copies the results afterwards */
storage::copy_from_temp_freq              = 5                                 /*!< How often, in units of iterations, to copy the hdf5 file in tmp dir to target destination */
storage::temp_dir                         = /tmp                              /*!< Local temp directory on the local system. If it does not exist we default to /scratch/local or /tmp instead (or whatever is the default) */
storage::compression_level                = 8                                 /*!< GZip compression level in HDF5. Choose between [0-9] (0 = off, 9 = max compression) */
storage::file_collision_policy            = REVIVE                           /*!< What to do when a prior output file is found. Choose between RESUME, REVIVE, BACKUP, RENAME, REPLACE */
storage::file_resume_policy               = FAST                              /*!< Depends on dataset "common/finished_all=bool" FULL: Ignore bool -> Scan .cfg to add missing items. FAST: exit if true. */
storage::file_resume_name                 = ""                                /*!< On file_collision_policy=RESUME|REVIVE: resume from state candidate matching this string. Empty implies any */
storage::file_resume_iter                 = -1ul                              /*!< On file_collision_policy=RESUME|REVIVE: which iteration to resume from. -1ul implies resume from last available iteration */

// Storage Levels.
// NOTE 1: A simulation can only be resumed from FULL storage.
// NOTE 2: storage_level_model == NORMAL is enough to recreate MPOs when resuming, since they can be reconstructed from the Hamiltonian parameter table
//      NONE:   no data is saved at all
//      LIGHT:  Mainly table entries. Hamiltonian, measurements (energy/entropy etc), simulation status and profiling (if save_timers == true)
//      NORMAL: Same as LIGHT + whole chain schmidt values (lambda-matrices)
//      FULL:   Same as NORMAL + MPS (A/B matrices) + MPO at each site.
storage::storage_level_model               = NORMAL                           /*!< Storage level for the model realization. LIGHT stores nothing. NORMAL stores the Hamiltonian parameter table, and FULL also the MPOs */
storage::storage_level_savepoint           = NONE                             /*!< Storage level for savepoints, which are snapshots taken at each iteration or snapshot taken at the end of each iteration */
storage::storage_level_checkpoint          = NORMAL                           /*!< Storage level for checkpoints, which are mid-simulation measurements */
storage::storage_level_finished            = FULL                             /*!< Storage level for final results written when a simulation terminates successfully */
storage::storage_level_proj_state          = NONE                             /*!< Storage level for the parity projected states, a projected version of the state written when a simulation terminates */
storage::storage_level_init_state          = NONE                             /*!< Storage level for the initial states (for instance when launching a simulation or starting a new state) */
storage::storage_level_emin_state          = NONE                             /*!< Storage level for the minimum energy state (ground state) */
storage::storage_level_emax_state          = NONE                             /*!< Storage level for the maximum energy state */
storage::storage_level_bond_state          = NORMAL                           /*!< Storage level for states written on bond limit change */
storage::storage_level_trnc_state          = NORMAL                           /*!< Storage level for states written on truncation error limit change */
storage::storage_level_fes_state           = NORMAL                           /*!< Storage level for states written during finite entanglement scaling (fes) after the main simulation */


//Parmaters that control solvers such as eigs, svd and bfgs
solver::eigs_iter_max                   = 50000                             /*!< Maximum number of steps for eigenvalue solver. */
solver::eigs_tol_min                    = 1e-14                             /*!< Minimum precision tolerance for halting the eigenvalue solver. */
solver::eigs_tol_max                    = 1e-8                              /*!< Maximum (default) precision tolerance for halting the eigenvalue solver. */
solver::eigs_ncv                        = 4                                 /*!< Parameter controlling the krylov/column space of the Arnoldi eigenvalue solver */
solver::bfgs_max_iter                   = 50000                             /*!< Maximum number of iterations for the L-BFGS solver. */
solver::iter_stuck_multiplier           = 4                                 /*!< Increase number of iterations on BFGS/EIGS by this factor when stuck */
solver::max_size_full_eigs              = 3000                              /*!< Maximum problem size allowed for full diagonalization of the local (effective) hamiltonian matrix. */
solver::max_size_shift_invert           = 4096                              /*!< Maximum problem size allowed for partial diagonalization of the local (effective) hamiltonian matrix. */
solver::bfgs_fix_rnorm_w_eigs           = false                             /*!< Use the eigenvalue solver for (H-E/L)² when BFGS returns with bad gradient */
solver::prefer_eigs_over_bfgs           = ALWAYS                            /*!< Prefer using the eigenvalue solver for (H-E/L)² over BFGS. Choose {NEVER, WHEN_SATURATED, ALWAYS} */
solver::svd_truncation_lim              = 1e-32                             /*!< Truncation error limit, i.e. discard singular values while the truncation error is lower than this */
solver::svd_truncation_init             = 1e-16                             /*!< If truncation error limit is updated (trnc_decrease_when != NEVER), start from this value */
solver::svd_switchsize_bdc              = 16                                /*!< Linear size of a matrix, below which SVD will use slower but more precise JacobiSVD instead of BDC (default is 16 , good could be ~64) */


// Options for strategy that affect convergence and targeted state
strategy::move_sites_when_stuck           = false                             /*!< Try moving sites around when stuck */
strategy::project_on_saturation           = 1                                 /*!< Project to target axis/parity sector every nth iteration when saturated. (0 = turn off) */
strategy::project_on_every_iter           = 1                                 /*!< Project to target axis/parity sector at the end of every nth iteration. This implies doing it when stuck also. */
strategy::project_on_bond_update          = true                              /*!< Project to target axis/parity sector before the bond dimension limit is increased (only works if bond_increase_when == true). */
strategy::project_initial_state           = true                              /*!< Project to target axis/parity sector when initializing a state. */
strategy::project_final_state             = true                              /*!< Project to target axis/parity sector before writing down the final state */
strategy::randomize_on_bond_update        = false                             /*!< Randomize MPS by flipping random spins when growing the bond dimension */
strategy::randomize_early                 = false                             /*!< Randomize MPS by flipping random spins before fully converging the first attempt (because the first attempt is biased) */
strategy::use_eigenspinors                = false                             /*!< Use random pauli-matrix eigenvectors when initializing each mps site along x,y or z  */
strategy::max_resets                      = 1                                 /*!< Maximum number of resets to product state due to saturation. One must be allowed for initialization */
strategy::max_stuck_iters                 = 5                                 /*!< If stuck for this many iterations -> stop. */
strategy::max_saturation_iters            = 2                                 /*!< If either variance or entanglement saturated this long -> algorithm saturated = true */
strategy::min_saturation_iters            = 0                                 /*!< Saturated at least this many iterations before stopping */
strategy::min_converged_iters             = 2                                 /*!< Converged at least this many iterations before success */
strategy::max_env_expansion_alpha         = 1e-4                              /*!< Maximum value of alpha used in environment expansion */
strategy::multisite_mps_site_def          = 1                                 /*!< Default number of sites in a multisite mps. More than ~8 is very expensive */
strategy::multisite_mps_site_max          = 4                                 /*!< Maximum number of sites in a multisite mps (used when stuck). More than ~8 is very expensive */
strategy::multisite_mps_move              = ONE                               /*!< How many sites to move after a multi-site dmrg step, choose between {ONE, MID, MAX} */
strategy::multisite_mps_when              = NEVER                             /*!< When to increase the number of sites in a DMRG step {NEVER, STUCK, SATURATED, ALWAYS} */
strategy::target_axis                     = z                                 /*!< Find an eigenstate with global spin component along this axis. Choose between Choose {none, (+-) x,y or z}  */
strategy::initial_axis                    = z                                 /*!< Initialize state with global spin component along this axis. Choose {none, (+-) x,y or z}  */
strategy::initial_type                    = REAL                              /*!< Initial state can be REAL/CPLX */
strategy::initial_state                   = RANDOM_PRODUCT_STATE              /*!< Initial configuration for the spin chain (only for finite systems)  */
strategy::secondary_states                = RANDOM_ENTANGLED_STATE            /*!< Spin configuration for subsequent states (only for finite systems)  */
strategy::fes_rate                        = 4                                 /*!< If |fes_rate| > 0, runs a finite entanglement scaling (fes) analysis with this step size in bond dimension, after finishing the main algorithm */
strategy::bond_increase_when              = NEVER                             /*!< If and when to increase the bond dimension limit {NEVER, TRUNCATED, STUCK, SATURATED, ITERATION}. */
strategy::bond_increase_rate              = 8                                 /*!< Bond dimension growth rate. Factor if 1<x<=2, constant shift if x > 2, otherwise invalid. */
strategy::trnc_decrease_when              = SATURATED                         /*!< If and when to decrease SVD truncation error limit {NEVER, TRUNCATED, STUCK, SATURATED, ITERATION} */
strategy::trnc_decrease_rate              = 1e-4                              /*!< Decrease SVD truncation error limit by this factor. Valid if 0 < x < 1 */

//Parmaters that control MPS precision
precision::use_compressed_mpo_squared_all  = true                              /*!< Use SVD to compress the bond dimensions of all H² mpos at the end of an iteration */
precision::use_compressed_mpo_squared_otf  = false                             /*!< Use SVD to compress the bond dimensions of the multisite H² mpo on-the-fly, just before an optimization step  */
precision::use_mpo_energy_shift            = true                              /*!< Whether to subtract E/L from ALL mpos to avoid catastrophic cancellation when computing the variance */
precision::use_mpo_parity_shift            = true                              /*!< Lift degeneracy by redefining H² --> (H² + Q(σ)) where Q(σ) = 0.5(1 - prod(σ)) = P(-σ) is the (flipped sign) projection operator */
precision::variance_convergence_threshold  = 1e-12                             /*!< Variance convergence threshold. The MPS state is considered good enough when its variance reaches below this value */
precision::variance_saturation_sensitivity = 5e-2                              /*!< Energy variance saturates when it stops changing. This sets the sensitivity to change. Good values are 1e-1 to 1e-4   */
precision::entropy_saturation_sensitivity  = 5e-3                              /*!< Entanglement entropy saturates when it stops changing. This sets the sensitivity to change. Good values are 1e-1 to 1e-4   */
precision::target_subspace_error           = 1e-10                             /*!< The target subspace error 1-Σ|<ϕ_i|ψ>|². Eigenvectors are found until reaching this value. Measures whether the incomplete basis of eigenstates spans the current state. */
precision::max_subspace_size               = 256                               /*!< Maximum number of candidate eigenstates to keep for a subspace optimization step */
precision::max_size_multisite              = 1180000                           /*!< Maximum problem size for multisite dmrg. If the linear size is larger than this, the algorithm prefers 1-site dmrg. */
precision::max_norm_error                  = 1e-10                             /*!< Maximum norm deviation from unity during integrity checks */

//Parameters for the transvese-field next-nearest neighbor Ising model with a random field
model::ising_tf_rf::J1                    = 1.0                               /*!< Ferromagnetic coupling for nearest neighbors.*/
model::ising_tf_rf::J2                    = 0.0                               /*!< Ferromagnetic coupling for next-nearest neighbors.*/
model::ising_tf_rf::h_tran                = 1.0                               /*!< Transverse field strength */
model::ising_tf_rf::h_mean                = 0.0                               /*!< Random field mean of distribution */
model::ising_tf_rf::h_wdth                = 0.0                               /*!< Random field width of distribution */
model::ising_tf_rf::spin_dim              = 2                                 /*!< Spin dimension */
model::ising_tf_rf::distribution          = normal                            /*!< Random distribution for couplings and fields */

//Parameters for the selfdual transverse-field random-field next-nearest neighbor Ising model
model::ising_sdual::lambda                = 0.0                               /*!< Width of the distribution for the J_rand coupling */
model::ising_sdual::delta                 = 0.0                               /*!< Width of the distribution for the h_rand on-site field */
model::ising_sdual::spin_dim              = 2                                 /*!< Separation of +-Z parity sectors */
model::ising_sdual::parity_sep            = false                             /*!< Spin dimension */
model::ising_sdual::distribution          = uniform                           /*!< Random distribution for couplings and fields */

/*! Parameters for the Ising-Majorana model */
model::ising_majorana::g                  = 0.01                              /*!< Interaction parameter for nearest ZZ and next-nearest XX neighbor coupling */
model::ising_majorana::delta              = 0.0                               /*!< Delta defined as log(J_mean) - log(h_mean). We get J_mean and h_mean by fixing delta = 2lnW, W = J_wdth = 1/h_wdth */
model::ising_majorana::spin_dim           = 2                                 /*!< Spin dimension */
model::ising_majorana::parity_sep         = false                             /*!< Separation of +-Z parity sectors */
model::ising_majorana::distribution       = uniform                           /*!< Random distribution for couplings and fields */

//Parameters for the l-bit hamiltonian
model::lbit::J1_mean                      = 0.00                              /*!< Constant offset for on-site */
model::lbit::J2_mean                      = 0.00                              /*!< Constant offset for two-body interaction */
model::lbit::J3_mean                      = 0.00                              /*!< Constant offset for three-body interaction */
model::lbit::J1_wdth                      = 1.00                              /*!< Width of the distribution for on-site interactions. */
model::lbit::J2_wdth                      = 0.25                              /*!< Width of the distribution for two-body interaction. */
model::lbit::J3_wdth                      = 0.10                              /*!< Width of the distribution for three-body interaction. */
model::lbit::J2_xcls                      = 0.8                               /*!< Exp. decay rate of two-body interactions: exp(-|i-j|/J2_xcls) * J2_rand */
model::lbit::J2_span                      = -1                                /*!< Maximum allowed range for pairwise interactions, |i-j| <= J2_span. Use -1 for infinite. Note that J2_span + 1 MPOs are used */
model::lbit::f_mixer                      = 0.25                              /*!< Mixing factor for unitary transformation to real-space */
model::lbit::u_layer                      = 4                                 /*!< Number of unitary 2-site layers which transform lbit <-> real spaces */
model::lbit::spin_dim                     = 2                                 /*!< Spin dimension */
model::lbit::distribution                 = normal                            /*!< Random distribution for interaction strengths */

// Settings for the infinite DMRG algorithm
idmrg::on                                 = false                             /*!< Turns iDMRG simulation on/off. */
idmrg::max_iters                          = 500                               /*!< Maximum number of iDMRG iterations before forced termination */
idmrg::bond_max                           = 64                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
idmrg::bond_init                          = 8                                 /*!< Initial bond dimension limit. Only used when bond_grow == true. */
idmrg::print_freq                         = 1                                 /*!< Print frequency for console output. In units of iterations.  (0 = off). */

// Settings for the imaginary-time infinite TEBD algorithm
itebd::on                                 = false                             /*!< Turns iTEBD simulation on/off. */
itebd::max_iters                          = 50                                /*!< Maximum number of iTEBD iterations before forced termination */
itebd::time_step_init_real                = 0.1                               /*!< Real part of initial time step delta_t */
itebd::time_step_init_imag                = 0.0                               /*!< Imag part of initial time step delta_t */
itebd::time_step_min                      = 0.0001                            /*!< (Absolute value) Minimum and final time step for iTEBD time evolution. */
itebd::suzuki_order                       = 4                                 /*!< Order of the suzuki trotter decomposition (1,2 or 4) */
itebd::bond_max                           = 16                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
itebd::bond_init                          = 16                                /*!< Initial bond dimension limit. Only used when bond_grow == true. */
itebd::print_freq                         = 1                                 /*!< Print frequency for console output. In units of iterations. (0 = off).*/

// Settings for the finite DMRG algorithm
fdmrg::on                                 = false                             /*!< Turns fdmrg simulation on/off. */
fdmrg::max_iters                          = 30                                /*!< Max number of iterations. One iterations moves L steps. */
fdmrg::min_iters                          = 6                                 /*!< Min number of iterations. One iterations moves L steps. */
fdmrg::bond_max                           = 128                               /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
fdmrg::bond_init                          = 16                                /*!< Initial bond dimension limit. Only used when bond_grow == true. */
fdmrg::print_freq                         = 1                                 /*!< Print frequency for console output. In units of iterations. (0 = off). */
fdmrg::store_wavefn                       = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */

// Settings for the finite l-bit algorithm
flbit::on                                 = false                             /*!< Turns flbit simulation on/off. */
flbit::max_iters                          = 500                               /*!< Max number of iterations. One iterations moves L steps. */
flbit::min_iters                          = 1                                 /*!< Min number of iterations. One iterations moves L steps. */
flbit::use_swap_gates                     = true                              /*!< Use gate swapping for pairwise long-range interactions rather then building a large multisite operator */
flbit::bond_max                           = 2048                              /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
flbit::bond_init                          = 16                                /*!< Initial bond dimension limit. Used during iter <= 1 or when bond_grow == true, or starting from an entangled state */
flbit::time_start_real                    = 1e-1                              /*!< Starting time point (real) */
flbit::time_start_imag                    = 0                                 /*!< Starting time point (imag) */
flbit::time_final_real                    = 1e14                              /*!< Finishing time point (real) */
flbit::time_final_imag                    = 0                                 /*!< Finishing time point (imag) */
flbit::time_num_steps                     = 100                               /*!< Number of steps from start to finish. Start and final times are included */
flbit::time_gate_id_threshold             = 1e-3                              /*!< Skip time evo. gates if exp(-iHt) is ~ 1 within this threshold */
flbit::print_freq                         = 1                                 /*!< Print frequency for console output. In units of iterations. (0 = off). */
flbit::compute_lbit_length                = false                             /*!< Calculate the characteristic length-scale of lbits */
flbit::compute_lbit_stats                 = false                             /*!< Calculate the statistics of characteristic length-scale for various u and f parameters */
flbit::store_wavefn                       = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */
flbit::save_swap_gates                    = false                             /*!< Saves the state and swap gates used later for benchmarks */

// Settings for the finite excited-state DMRG algorithm
xdmrg::on                                 = true                              /*!< Turns xDMRG simulation on/off. */
xdmrg::max_iters                          = 5000                              /*!< Max number of iterations. One iterations moves L steps. */
xdmrg::min_iters                          = 4                                 /*!< Min number of iterations. One iterations moves L steps. */
xdmrg::bond_max                           = 2048                              /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
xdmrg::bond_init                          = 8                                 /*!< Initial bond dimension limit. Used during iter <= 1 or when bond_grow == true, or starting from an entangled state */
xdmrg::opt_overlap_iters                  = 2                                 /*!< Number of initial iterations selecting the candidate state with best overlap to the current state */
xdmrg::opt_overlap_bond_lim               = 8                                 /*!< Bond limit during initial OVERLAP optimization. set to <= 0 for unlimited */
xdmrg::opt_subspace_iters                 = 0                                 /*!< Number of iterations using the subspace optimization of variance, after the overlap iterations */
xdmrg::opt_subspace_bond_lim              = 48                                /*!< Bond limit during initial SUBSPACE optimization. set to <= 0 for unlimited */
xdmrg::print_freq                         = 1                                 /*!< Print frequency for console output. In units of iterations. (0 = off). */
xdmrg::energy_density_target              = 0.5                               /*!< Target energy in [0-1], where 0.5 means middle of spectrum. */
xdmrg::energy_density_window              = 0.5                               /*!< Accept states inside of energy_tgt_per_site +- energy_dens_window. */
xdmrg::max_states                         = 1                                 /*!< Max number of random states to find using xDMRG on a single disorder realization */
xdmrg::store_wavefn                       = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */
xdmrg::finish_if_entanglm_saturated       = false                             /*!< Finish early as soon as entanglement has saturated */
xdmrg::finish_if_variance_saturated       = false                             /*!< Finish early as soon as energy variance has saturated */
