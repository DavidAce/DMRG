
//Parameters for saving data to hdf5
output::save_logs                         = true                              /*!< If true, saves the history of the simulation in log files, not just the end results  (only enabled on storage level NORMAL and FULL.) */
output::save_profiling                    = true                              /*!< Whether to save profiling information to file. (only enabled on storage level NORMAL and FULL.) */
output::output_filename                   = output/mbl.h5                     /*!< Name of the output HDF5 file relative to the execution point  */
output::access_mode                       = READWRITE                         /*!< Choose access mode to the file. Choose between READWRITE, READONLY */
output::create_mode                       = TRUNCATE                          /*!< Choose access mode to the file. Choose between TRUNCATE, OPEN, RENAME */
output::storage_level                     = 2                                 /*!< Sets the storage level: choose 0=NONE,1=LIGHT,2=NORMAL,3=FULL */
output::use_temp_dir                      = true                              /*!< If true uses a temporary directory for writes in the local drive (usually /tmp) and copies the results afterwards */
output::copy_from_temp_freq               = 4                                 /*!< How often, in units of iterations, to copy the hdf5 file in tmp dir to target destination */
output::temp_dir                          = /dev/shm                          /*!< Local temp directory on the local system. If it does not exist we default to /scratch/local or /tmp instead (or whatever is the default) */

// Parameters for OpenMP
// Make sure just one of these is > 1 otherwise too many threads
// may be spawned inside of already threaded parts.
threading::num_threads            = 1                                         /*!< Number of threads for OpenMP operations. num_threads <= 0 will try to use as many as possible */


//Common parameters for the model Hamiltonian
model::model_type                         = selfdual_tf_rf_ising              /*!< Choice of model: {tf_ising, selfdual_tf_rf_ising,selfdual_tf_rf_ising_ps,selfdual_tf_rf_ising_normal} */
model::seed                               = 1                                 /*!< Main seed for the random number generator. */
model::state_number                       = -1                                /*!< Number whose bitfield represents the initial product state in the basis given by initial_parity_sector. Only positive state numbers are used */
model::chi_quench_when_stuck              = true                              /*!< Reduce chi during a sweep when stuck and increasing bond dimension would not help */
model::perturb_when_stuck                 = false                             /*!< Perturb MPO parameters to get unstuck from local minima */
model::damping_when_stuck                 = false                             /*!< Dampen MPO parameters by reducing disorder, to get unstuck from local minima */
model::project_trial_when_stuck           = true                              /*!< Project to target parity sector at each sweep when stuck. */
model::project_when_growing_chi           = false                             /*!< Project to target parity sector when bond dimension is increased (only works if chi_grow == true). */
model::project_on_every_sweep             = false                             /*!< Project to target parity sector at each sweep. This implies doing it when stuck also. */
model::use_pauli_eigvecs                  = true                              /*!< Use random pauli eigenvectors to initialize spinors in x,y or z  */
model::initial_parity_sector              = x                                 /*!< Initialize in parity symmetry sector: {x,+x,-x, y, +y,-y, z,+z,-z, randomAxis,random,none} */
model::target_parity_sector               = x                                 /*!< Project to this sector when saturated: {x,+x,-x, y, +y,-y, z,+z,-z, randomAxis,random,none} */


//Parameters for the transverse-field Ising model
model::tf_ising::J                        = 1                                 /*!< Ferromagnetic coupling. J < 0  Gives a ferromagnet. J > 0 an antiferromagnet. */
model::tf_ising::g                        = 1                                 /*!< Transverse field strength */
model::tf_ising::w                        = 0                                 /*!< Randomness strength for the random field */
model::tf_ising::d                        = 2                                 /*!< Local spin dimension */

//Parameters for the transvese-field next-nearest neighbor Ising model
model::tf_nn_ising::J1                    = 1                                 /*!< Ferromagnetic coupling for nearest neighbors.*/
model::tf_nn_ising::J2                    = 1                                 /*!< Ferromagnetic coupling for next-nearest neighbors.*/
model::tf_nn_ising::g                     = 1                                 /*!< Transverse field strength */
model::tf_nn_ising::w                     = 0                                 /*!< Randomness strength for the random field */
model::tf_nn_ising::d                     = 2                                 /*!< Local spin dimension */


//Parameters for the selfdual transverse-field random-field next-neighbor Ising model
model::selfdual_tf_rf_ising::J_mean       = 1.0                               /*!< Mean for the log-normal distribution defining ferromagnetic coupling strength.*/
model::selfdual_tf_rf_ising::h_mean       = 1.0                               /*!< Mean for the log-normal distribution defining transverse magnetic field strength */
model::selfdual_tf_rf_ising::J_sigma      = 1.0                               /*!< Standard deviation for the log-normal distribution defining ferromagnetic coupling */
model::selfdual_tf_rf_ising::h_sigma      = 1.0                               /*!< Standard deviation for the log-normal distribution defining transverse magnetic field */
model::selfdual_tf_rf_ising::lambda       = 0.0                               /*!< Lambda parameter */
model::selfdual_tf_rf_ising::d            = 2                                 /*!< Spin dimension */
model::selfdual_tf_rf_ising::parity_sep   = false                             /*!< Separation of +-X parity sectors */
model::selfdual_tf_rf_ising::distribution = lognormal                         /*!< Random distribution for couplings and fields */

//Parmaters that control MPS, eigensolver and SVD precision
precision::eig_max_iter                   = 1000                              /*!< Maximum number of steps for eigenvalue solver. */
precision::eig_threshold                  = 1e-12                             /*!< Minimum threshold for halting eigenvalue solver. */
precision::eig_max_ncv                    = 16                                /*!< Parameter controlling the column space? of the Lanczos solver. 16 is close to optimum when chi = 16. Coincidence? */
precision::svd_threshold                  = 1e-8                              /*!< Minimum threshold value for keeping singular values. */
precision::variance_convergence_threshold = 1e-14                             /*!< Variance convergence threshold. The MPS state is considered good enough when its variance reaches below this value */
precision::variance_slope_threshold       = 10                                /*!< Variance saturation slope threshold [0-100%]. The variance has saturated when its (absolute) slope reaches below this value. 2 would mean the data saturates when it changes less than 2% per iteration */
precision::entropy_slope_threshold        = 2                                 /*!< Entanglement Entropy saturation slope threshold [0-100%]. The entanglement entropy has saturated when its (absolute) slope reaches below this value. 2 would mean the data saturates when it changes less than 2% per iteration */
precision::subspace_error_factor          = 1                                 /*!< Minimum quality of subspace for going ahead in variance optimization. If the quality is too bad, direct optimization is done instead */
precision::max_subspace_error             = 1e-12                             /*!< The maximum subspace error. Never do subspace variance optimization with subspace error greater than this. */
precision::min_subspace_error             = 1e-12                             /*!< The minimum subspace error. Always do subspace variance optimization with subspace error less than this  */
precision::max_size_full_diag             = 2048                              /*!< Maximum linear size allowed for full diagonalization of the local hamiltonian matrix. Use 0 to allow any value */
precision::max_size_part_diag             = 4096                              /*!< Maximum linear size allowed for partial diagonalization of the local hamiltonian matrix. Use 0 to allow any value */
precision::max_size_direct                = 100000                            /*!< Maximum linear size for direct multisite dmrg. If the linear size is larger than this, the algorithm prefers 2-site dmrg. */
precision::max_norm_error                 = 1e-10                             /*!< Maximum norm deviation from unity during integrity checks */
precision::max_resets                     = 10                                /*!< Maximum number of resets to initial state. One must be allowed for initialization*/
precision::use_reduced_energy             = true                              /*!< Whether to subtract E/L from each mpo to avoid catastrophic cancellation when computing the variance */
precision::max_sites_multidmrg            = 6                                 /*!< Maximum number of sites in multi-site dmrg. Too many sites (>12 or so) makes the contractions slow. */
precision::move_sites_multidmrg           = one                               /*!< How many sites to move after a multi-site dmrg step, choose between {one,mid,max} */

//Parameters controlling iDMRG
idmrg::on                                 = false                             /*!< Turns iDMRG simulation on/off. */
idmrg::max_steps                          = 500                               /*!< Number of steps for the simulation. */
idmrg::chi_max                            = 64                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
idmrg::chi_grow                           = true                              /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
idmrg::chi_init                           = 8                                 /*!< Initial chi limit. Only used when chi_grow == true. */
idmrg::print_freq                         = 1                                 /*!< Print frequency for console output. (0 = off).*/
idmrg::write_freq                         = 10                                /*!< Write frequency,for output file buffer. (0 = off). */

//Parameters controlling fDMRG
fdmrg::on                                 = false                             /*!< Turns fDMRG simulation on/off. */
fdmrg::num_sites                          = 16                                /*!< Number of sites on the 1D quantum chain. */
fdmrg::max_sweeps                         = 96                                /*!< Max number of sweeps along the 1D quantum chain. */
fdmrg::min_sweeps                         = 4                                 /*!< Min number of sweeps along the 1D quantum chain. */
fdmrg::chi_max                            = 256                               /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
fdmrg::chi_grow                           = true                              /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
fdmrg::chi_init                           = 16                                /*!< Initial chi limit. Only used when chi_grow == true. */
fdmrg::print_freq                         = 1                                 /*!< Print frequency for console output. In units of sweeps. (0 = off).*/
fdmrg::write_freq                         = 1                                 /*!< Write frequency,for output file buffer. In units of steps. (0 = off). */
fdmrg::store_wavefn                       = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */

//Parameters controlling xDMRG
xdmrg::on                                 = true                              /*!< Turns xDMRG simulation on/off. */
xdmrg::num_sites                          = 24                                /*!< Number of sites on the 1D quantum chain. */
xdmrg::max_sweeps                         = 200                               /*!< Max number of sweeps along the 1D quantum chain. */
xdmrg::min_sweeps                         = 4                                 /*!< Min number of sweeps along the 1D quantum chain. */
xdmrg::chi_max                            = 512                               /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
xdmrg::chi_grow                           = true                              /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
xdmrg::chi_init                           = 4                                 /*!< Initial chi limit. Only used when chi_grow == true. */
xdmrg::print_freq                         = 1                                 /*!< Print frequency for console output. In units of steps. (0 = off).*/
xdmrg::write_freq                         = 1                                 /*!< Write frequency,for output file buffer. In units of steps. (0 = off). */
xdmrg::store_wavefn                       = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */
xdmrg::energy_density_target              = 0.5                               /*!< Target energy in [0-1], where 0.5 means middle of spectrum. */
xdmrg::energy_density_window              = 0.5                               /*!< Accept states inside of energy_target +- energy_window. */

//Parameters controlling iTEBD
itebd::on                                 = false                             /*!< Turns iTEBD simulation on/off. */
itebd::max_steps                          = 1000                              /*!< Number of iTEBD iterations, after which the simulation terminates regardless of convergence. Set high. */
itebd::delta_t0                           = 0.1                               /*!< Initial time step for iTEBD time evolution. */
itebd::delta_tmin                         = 0.0001                            /*!< Final time step for iTEBD time evolution. */
itebd::suzuki_order                       = 4                                 /*!< Order of the suzuki trotter decomposition (1,2 or 4) */
itebd::chi_max                            = 16                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
itebd::chi_grow                           = false                             /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
itebd::chi_init                           = 16                                /*!< Initial chi limit. Only used when chi_grow == true. */
itebd::print_freq                         = 50                                /*!< Print frequency for console output. (0 = off). */
itebd::write_freq                         = 50                                /*!< Write frequency,for output file buffer. (0 = off). */

//Parameters to control profiling.
profiling::on                             = true                              /*!< If true, turns on profiling and timings will be shown on console. */
profiling::precision                      = 5                                 /*!< Sets precision (number of decimals) of time output. */

//Console settings
console::verbosity                        = 1                                 /*!< Level of verbosity desired [0-6]. Level 0 prints everything, 6 nothing. Level 2 or 3 is recommended for normal use */
console::timestamp                        = true                              /*!< (NOT IMPLEMENTED) Whether to put a timestamp on console outputs */
