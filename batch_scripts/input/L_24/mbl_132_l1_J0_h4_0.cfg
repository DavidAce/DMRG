//
// Created by david on 8/7/17.
//



//Common parameters for the model Hamiltonian
model::model_type             = selfdual_tf_rf_ising        /*!< Choice of model: {tf_ising, selfdual_tf_rf_ising} */
model::initial_state          = rps                         /*!< Choose initial state of the MPS: {upup, updown, GHZ(upup+downdown), W(updown+downup), rps (random product state), random_chi (random state with bond dimension chi)} "cat" or "random". Default "rps". Note that "random_chi" works poorly for finite algorithms */

//Parameters for the transverse-field Ising model
model::tf_ising::J            = 1                           /*!< Ferromagnetic coupling. J < 0  Gives a ferromagnet. J > 0 an antiferromagnet. */
model::tf_ising::g            = 1                           /*!< Transverse field strength */
model::tf_ising::w            = 0                           /*!< Randomness strength for the random field */
model::tf_ising::d            = 2                           /*!< Local spin dimension */

//Parameters for the transvese-field next-nearest neighbor Ising model
model::tf_nn_ising::J1        = 1                           /*!< Ferromagnetic coupling for nearest neighbors.*/
model::tf_nn_ising::J2        = 1                           /*!< Ferromagnetic coupling for next-nearest neighbors.*/
model::tf_nn_ising::g         = 1                           /*!< Transverse field strength */
model::tf_nn_ising::w         = 0                           /*!< Randomness strength for the random field */
model::tf_nn_ising::d         = 2                           /*!< Local spin dimension */


//Parameters for the selfdual transvese-field random-field next-neighbor Ising model
model::selfdual_tf_rf_ising::J_log_mean = 1.00              /*!< Mean of log J, where J is the ferromagnetic coupling strength.*/
model::selfdual_tf_rf_ising::h_log_mean = 0.00              /*!< Mean of log h, where h is the transverse magnetic field strength */
model::selfdual_tf_rf_ising::J_sigma    = 1.0               /*!< Standard deviation for the lognormal distribution, i.e. = std(log(J)) , for the ferromagnetic coupling */
model::selfdual_tf_rf_ising::h_sigma    = 1.0               /*!< Standard deviation for the lognormal distribution, i.e. = std(log(J))   for the transverse magnetic field */
model::selfdual_tf_rf_ising::lambda     = 0.10              /*!< Lambda parameter */
model::selfdual_tf_rf_ising::d          = 2                 /*!< Local spin dimension */


//Parmaters that control MPS, eigensolver and SVD precision
precision::eigMaxIter                   = 1000             /*!< Maximum number of steps for eigenvalue solver. */
precision::eigThreshold                 = 1e-12            /*!< Minimum threshold for halting eigenvalue solver. */
precision::eigMaxNcv                    = 16               /*!< Parameter controlling the column space? of the Lanczos solver. 16 is close to optimum when chi = 16. Coincidence? */
precision::SVDThreshold                 = 1e-12            /*!< Minimum threshold value for keeping singular values. */
precision::VarConvergenceThreshold      = 1e-8             /*!< Variance convergence threshold. The MPS state is considered good enough when its variance reaches below this value */
precision::VarSaturationThreshold       = 1e-1             /*!< Variance saturation  threshold. The variance has saturated when its (absolute) slope reaches below this value. 1e-2 would mean the data saturates when it changes less than 1% per iteration */
precision::EntEntrSaturationThreshold   = 1e-1             /*!< Entanglement Entropy saturation threshold. The entanglement entropy has saturated when its (absolute) slope reaches below this value. 1e-2 would mean the data saturates when it changes less than 1% per iteration*/


//Parameters controlling iDMRG
idmrg::on                       = false                     /*!< Turns iDMRG simulation on/off. */
idmrg::max_steps                = 50                        /*!< Number of steps for the simulation. */
idmrg::chi_max                  = 16                        /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
idmrg::chi_grow                 = false                     /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
idmrg::print_freq               = 1                         /*!< Print frequency for console output. (0 = off).*/
idmrg::store_freq               = 10                        /*!< Store frequency,for output file buffer. (0 = off). */

//Parameters controlling fDMRG
fdmrg::on                       = false                     /*!< Turns fDMRG simulation on/off. */
fdmrg::max_length               = 24                        /*!< Number sweeps along the 1D quantum chain. */
fdmrg::max_sweeps               = 10                        /*!< Number sweeps along the 1D quantum chain. */
fdmrg::chi_max                  = 6                         /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
fdmrg::chi_grow                 = false                     /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
fdmrg::print_freq               = 1                         /*!< Print frequency for console output. In units of sweeps. (0 = off).*/
fdmrg::store_freq               = 1                         /*!< Store frequency,for output file buffer. In units of sweeps. (0 = off). */

//Parameters controlling xDMRG
xdmrg::on                       = true                      /*!< Turns xDMRG simulation on/off. */
xdmrg::max_length               = 24                        /*!< Number of sites on the 1D quantum chain. */
xdmrg::max_sweeps               = 48                        /*!< Number sweeps along the 1D quantum chain. */
xdmrg::chi_max                  = 32                        /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
xdmrg::chi_grow                 = true                      /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
xdmrg::seed                     = 132                       /*!< Seed for the random number generator if you use random fields in the Hamiltonian. */
xdmrg::print_freq               = 1                         /*!< Print frequency for console output. In units of sweeps. (0 = off).*/
xdmrg::store_freq               = 1                         /*!< Store frequency,for output file buffer. In units of sweeps. (0 = off). */
xdmrg::store_wavefn             = false                     /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */

//Parameters controlling iTEBD
itebd::on                       = false                     /*!< Turns iTEBD simulation on/off. */
itebd::max_steps                = 100                       /*!< Number of iTEBD iterations, after which the simulation terminates regardless of convergence. Set high.*/
itebd::delta_t0                 = 0.1                       /*!< Initial time step for iTEBD time evolution.*/
itebd::delta_tmin               = 0.0001                    /*!< Final time step for iTEBD time evolution.*/
itebd::suzuki_order             = 4                         /*!< Order of the suzuki trotter decomposition (1,2 or 4) */
itebd::chi_max                  = 6                         /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
itebd::chi_grow                 = false                     /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
itebd::print_freq               = 1                         /*!< Print frequency for console output. (0 = off).*/
itebd::store_freq               = 10                        /*!< Store frequency,for output file buffer. (0 = off). */

//Parameters for saving data to hdf5
hdf5::save_to_file              = true                      /*!< (Not implemented yet) If true, saves the simulation data to an HDF5 file instead of just outputting to console */
hdf5::create_dir_if_not_found   = true                      /*!< If true, an output directory will be created in the project root folder if it isn't found */
hdf5::overwrite_file_if_found   = false                     /*!< If true, an hdf5-file with the provided filename will be overwritten if found in output_folder */
hdf5::output_filename           = mbl_0.h5                  /*!< Name of the output HDF5 file. Without quotes! */
hdf5::output_folder             = output/L_24/l_1/J_0/h_4   /*!< Name of the output HDF5 folder, with respect to the project root.
hdf5::full_storage              = false                     /*!< (Not implemented yet) If true, saves more simulation data to file (such as explicit form of MPS). Set to false to reduce output file size. */
hdf5::store_profiling           = false                     /*!< Whether to store profiling information to file. */

//Parameters to control profiling.
profiling::on                   = true                      /*!< If true, turns on profiling and timings will be shown on console. */
profiling::precision            = 5                         /*!< Sets precision (number of decimals) of time output. */

//Console settings
console::verbosity              = 0                         /*!< (PARTIALLY IMPLEMENTED) Level of verbosity desired [0-2]. Level 0 prints almost nothing, level 2 prints everything */
console::timestamp              = false                     /*!< (NOT IMPLEMENTED) Whether to put a timestamp on console outputs */

