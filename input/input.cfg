//
// Created by david on 8/7/17.
//



//Common parameters for the model Hamiltonian
model::model_type                       = selfdual_tf_rf_ising              /*!< Choice of model: {tf_ising, selfdual_tf_rf_ising} */
model::initial_state                    = rps                               /*!< Choose initial state of the MPS: {upup, updown, GHZ(upup+downdown), W(updown+downup), rps (random product state), random_chi (random state with bond dimension chi)} "cat" or "random". Default "rps". Note that "random_chi" works poorly for finite algorithms */
model::seed_init                        = 1                                 /*!< Seed for the random number generator if you use random fields in the Hamiltonian. */
model::symmetry                         = sx                                /*!< Initialize in parity symmetry sector: {sx,sy,sz,random,none}


//Parameters for the transverse-field Ising model
model::tf_ising::J                      = 1                                 /*!< Ferromagnetic coupling. J < 0  Gives a ferromagnet. J > 0 an antiferromagnet. */
model::tf_ising::g                      = 1                                 /*!< Transverse field strength */
model::tf_ising::w                      = 0                                 /*!< Randomness strength for the random field */
model::tf_ising::d                      = 2                                 /*!< Local spin dimension */

//Parameters for the transvese-field next-nearest neighbor Ising model
model::tf_nn_ising::J1                  = 1                                 /*!< Ferromagnetic coupling for nearest neighbors.*/
model::tf_nn_ising::J2                  = 1                                 /*!< Ferromagnetic coupling for next-nearest neighbors.*/
model::tf_nn_ising::g                   = 1                                 /*!< Transverse field strength */
model::tf_nn_ising::w                   = 0                                 /*!< Randomness strength for the random field */
model::tf_nn_ising::d                   = 2                                 /*!< Local spin dimension */


//Parameters for the selfdual transvese-field random-field next-neighbor Ising model
model::selfdual_tf_rf_ising::J_log_mean = 1.00                              /*!< Mean of log J, where J is the ferromagnetic coupling strength.*/
model::selfdual_tf_rf_ising::h_log_mean = 1.00                              /*!< Mean of log h, where h is the transverse magnetic field strength */
model::selfdual_tf_rf_ising::J_sigma    = 1.0                               /*!< Standard deviation for the lognormal distribution, i.e. = std(log(J)) , for the ferromagnetic coupling */
model::selfdual_tf_rf_ising::h_sigma    = 1.0                               /*!< Standard deviation for the lognormal distribution, i.e. = std(log(J))   for the transverse magnetic field */
model::selfdual_tf_rf_ising::lambda     = 0.00                              /*!< Lambda parameter */
model::selfdual_tf_rf_ising::d          = 2                                 /*!< Local spin dimension */

//Parmaters that control MPS, eigensolver and SVD precision
precision::eigMaxIter                   = 1000                              /*!< Maximum number of steps for eigenvalue solver. */
precision::eigThreshold                 = 1e-12                             /*!< Minimum threshold for halting eigenvalue solver. */
precision::eigMaxNcv                    = 16                                /*!< Parameter controlling the column space? of the Lanczos solver. 16 is close to optimum when chi = 16. Coincidence? */
precision::SVDThreshold                 = 1e-10                             /*!< Minimum threshold value for keeping singular values. */
precision::VarConvergenceThreshold      = 1e-10                             /*!< Variance convergence threshold. The MPS state is considered good enough when its variance reaches below this value */
precision::VarSaturationThreshold       = 1e-2                              /*!< Variance saturation  threshold. The variance has saturated when its (absolute) slope reaches below this value. 1e-2 would mean the data saturates when it changes less than 1% per iteration */
precision::EntEntrSaturationThreshold   = 1e-4                              /*!< Entanglement Entropy saturation threshold. The entanglement entropy has saturated when its (absolute) slope reaches below this value. 1e-2 would mean the data saturates when it changes less than 1% per iteration*/
precision::MaxSizeFullDiag              = 2048                              /*!< Maximum linear size allowed for full diagonalization of the local hamiltonian matrix. Use 0 to allow any value */
precision::MaxSizePartDiag              = 4096                              /*!< Maximum linear size allowed for full diagonalization of the local hamiltonian matrix. Use 0 to allow any value */

//Parameters controlling iDMRG
idmrg::on                               = false                             /*!< Turns iDMRG simulation on/off. */
idmrg::max_steps                        = 50                                /*!< Number of steps for the simulation. */
idmrg::chi_max                          = 16                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
idmrg::chi_grow                         = false                             /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
idmrg::print_freq                       = 10                                /*!< Print frequency for console output. (0 = off).*/
idmrg::store_freq                       = 10                                /*!< Store frequency,for output file buffer. (0 = off). */

//Parameters controlling fDMRG
fdmrg::on                               = false                             /*!< Turns fDMRG simulation on/off. */
fdmrg::num_sites                        = 16                                /*!< Number of sites on the 1D quantum chain. */
fdmrg::max_sweeps                       = 48                                /*!< Max number of sweeps along the 1D quantum chain. */
fdmrg::min_sweeps                       = 2                                 /*!< Min number of sweeps along the 1D quantum chain. */
fdmrg::chi_max                          = 128                               /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
fdmrg::chi_grow                         = false                             /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
fdmrg::print_freq                       = 1                                 /*!< Print frequency for console output. In units of sweeps. (0 = off).*/
fdmrg::store_freq                       = 1                                 /*!< Store frequency,for output file buffer. In units of sweeps. (0 = off). */
fdmrg::store_wavefn                     = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */

//Parameters controlling xDMRG
xdmrg::on                               = true                              /*!< Turns xDMRG simulation on/off. */
xdmrg::num_sites                        = 16                                /*!< Number of sites on the 1D quantum chain. */
xdmrg::max_sweeps                       = 48                                /*!< Max number of sweeps along the 1D quantum chain. */
xdmrg::min_sweeps                       = 4                                 /*!< Min number of sweeps along the 1D quantum chain. */
xdmrg::chi_max                          = 128                               /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
xdmrg::chi_grow                         = false                             /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
xdmrg::print_freq                       = 1                                 /*!< Print frequency for console output. In units of sweeps. (0 = off).*/
xdmrg::store_freq                       = 1                                 /*!< Store frequency,for output file buffer. In units of sweeps. (0 = off). */
xdmrg::store_wavefn                     = false                             /*!< Whether to store the wavefunction. Runs out of memory quick, recommended is false for max_length > 14 */
xdmrg::energy_density_target            = 0.5                               /*!< Target energy in [0-1], where 0.5 means middle of spectrum. */
xdmrg::energy_density_window            = 0.05                              /*!< Accept states inside of energy_target +- energy_window/2. */

//Parameters controlling iTEBD
itebd::on                               = false                             /*!< Turns iTEBD simulation on/off. */
itebd::max_steps                        = 1000                              /*!< Number of iTEBD iterations, after which the simulation terminates regardless of convergence. Set high.*/
itebd::delta_t0                         = 0.1                               /*!< Initial time step for iTEBD time evolution.*/
itebd::delta_tmin                       = 0.0001                            /*!< Final time step for iTEBD time evolution.*/
itebd::suzuki_order                     = 4                                 /*!< Order of the suzuki trotter decomposition (1,2 or 4) */
itebd::chi_max                          = 16                                /*!< Bond dimension of the current position (maximum number of singular values to keep in SVD). */
itebd::chi_grow                         = false                             /*!< Whether to increase chi slowly up to chi_max or go up to chi_max directly. */
itebd::print_freq                       = 50                                /*!< Print frequency for console output. (0 = off).*/
itebd::store_freq                       = 50                                /*!< Store frequency,for output file buffer. (0 = off). */

//Parameters for saving data to hdf5
hdf5::save_progress                     = true                              /*!< If true, saves the simulation data periodically */
hdf5::output_filename                   = output/mbl.h5                     /*!< Name of the output HDF5 file relative to the execution point  */
hdf5::access_mode                       = READWRITE                         /*!< Choose access mode to the file. Choose between READWRITE, READONLY */
hdf5::create_mode                       = TRUNCATE                          /*!< Choose access mode to the file. Choose between TRUNCATE, OPEN, RENAME */
hdf5::storage_level                     = 2                                 /*!< Sets the storage level: choose "0=NONE,1=LIGHT,2=NORMAL,3=FULL */
hdf5::store_profiling                   = false                             /*!< Whether to store profiling information to file. (only enabled on storage level NORMAL and FULL.) */

//Parameters to control profiling.
profiling::on                           = true                              /*!< If true, turns on profiling and timings will be shown on console. */
profiling::precision                    = 5                                 /*!< Sets precision (number of decimals) of time output. */

//Console settings
console::verbosity                      = 2                                 /*!< Level of verbosity desired [0-6]. Level 0 prints everything, 6 nothing. Level 2 or 3 is recommended for normal use */
console::timestamp                      = true                              /*!< (NOT IMPLEMENTED) Whether to put a timestamp on console outputs */
